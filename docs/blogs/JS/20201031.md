---
title: js中request的同步执行(踩坑系列)
date: 2020-10-31
tags:
 - 踩坑
 - 异步
 - 同步
categories:
 - nodejs
---

## Node.js 中 JavaScript 代码的执行顺序

​	**从开始执行的时间点上来看，Node.js 中的所有语句都是顺序执行的。**但是，由于 Node.js 的异步特性，先开始执行并不意味着先执行完毕。这就造成了 Node.js 似乎没有顺序执行的假象。单线程和异步确实不能同时成为一个语言的特性。js选择了成为单线程的语言，所以它本身不可能是异步的，但js的宿主环境（比如浏览器，Node）是多线程的，宿主环境通过某种方式（事件驱动，下文会讲）使得js具备了异步的属性。往下看，你会发现js的机制是多么的简单高效！

### await/async

```js
async function test(){
    return 200;
}
console.log(await test());//错误，await 必须用在 async 方法里
async function main(){
    var s=await test();	//获取异步方法的数据
}
```





### Promise

1.创建Promise实例

```javascript
var promise = new Promise(function(resolve, reject){
    // ... some code
    
    if (/* 异步操作成功 */) {
        resolve(value);
    } else {
        reject(error);
    }
})
```

2.then

 Promise实例生成后，可用`then`方法分别指定两种状态回调参数。then 方法可以接受两个回调函数作为参数：

①Promise对象状态改为Resolved时调用 （必选）

②Promise对象状态改为Rejected时调用 （可选）

示例：

```javascript
let promise = new Promise(function(resolve, reject){
    console.log("AAA");
    resolve()
});
promise.then(() => console.log("BBB"));
console.log("CCC")

// AAA
// CCC
// BBB
```

Promise新建后会立即执行，所以`首先输出 AAA`。然后，then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行，所以`BBB 最后输出`

```javascript
var request = require('request');
const GET = 'GET';
const POST = 'POST';
const PUT = 'PUT';
const FORM = 'FORM';
const DELETE = 'DELETE';
function requestpost(url, data){
    return new Promise((resolve, reject)=>{
        request({
            timeout: 5000,
            method:"POST",
            url: url,
            form: data
        },function(error,response,body){
            if (!error && response.statusCode == 200) {
                console.log(body);
                body_json = JSON.parse(body);
                if(body_json.status){
                    resolve(response.headers['set-cookie'])
                }
                else{
                    reject("登陆失败")
                }
            }
            else{
                console.log(error);
                reject("超星服务器出问题了··")
            }
        })
    })
}
function requestget(url,cookie){
    return new Promise((resolve, reject)=>{
        request({
            timeout: 5000,
            method:"GET",
            headers:{
             Cookie:cookie
            },
            url: url,
        },function(error,response,body){
            if (!error && response.statusCode == 200) {
                resolve(body)
            }
            else{
                reject("超星服务器出问题了··")
            }
        })
    })
}
module.exports = {
    requestget,
    requestpost
   }
//  requestpromise(POST,url,data).then(function(req){
//     console.log(req)
// }).catch(function(err){
//     console.log(err)
// })

// 无用参考

// request({
//     timeout:5000,    // 设置超时
//     method:'post',    //请求方式
//         url:url, //url
//         form:{
//             'uname': num,
//             'password': pwd,
//             't': 'true'
//         }
         
//     },function (error, response, body) {
//         if (!error && response.statusCode == 200) {
//             console.log(body);
//             var responseCookies = response.headers['set-cookie']
//             var requestCookies='';
//             for(var i=0; i<responseCookies.length; i++){
//                 var oneCookie = responseCookies[i];
//                 oneCookie = oneCookie.split(';');
//                 requestCookies= requestCookies + oneCookie[0]+';';
//                 request({
//                     timeout:5000,
//                     method:'GET',
//                     uri:"http://mooc1-1.chaoxing.com/visit/courses",
//                     headers:{
//                         Cookie: response.headers['set-cookie']
//                     }
//                 },function(error,response,body){
//                     console.log(body)
//                 }
//                 )
//             }
//              console.log(requestCookies)
//         }else{
//             console.log("error");
//         }
//     });


```



https://www.cnblogs.com/chenqionghe/p/11406666.html#%E4%BA%8C%E3%80%81%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8-then%E6%96%B9%E6%B3%95

https://blog.csdn.net/qingqingzijinxin/article/details/89095820

https://www.imooc.com/wenda/detail/498801

## node连接MySQL时查询timestamp类型格式错误

### 问题

mysql 日期的字段都是timeStamp 格式为YYYY-MM-DD  hh:mm:ss

将取到日期不做任何处理返回给前台又变成了下面的格式

2015-02-15T16:00:00.000Z

### 原因以及解决

这是 `Mysql时区` 与 `Node时区` 不一致导致的。

解决方法：配置Node数据库连接。
加上 `timezone` 这一行：

```js
client: {
	host: '***.***.***.***',
    port: '****',
    user: '****',
    timezone: "08:00"
 }
```

重启解决。